/* -LICENSE-START-
 ** Copyright (c) 2013 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

// Windows definitions

#pragma once

#include "comdef.h"

#include <conio.h>
#include <objbase.h>		// Necessary for COM
#include <comutil.h>
#include "DeckLinkAPI_h.h"
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>
#include <string>
#include <list>
#include <algorithm>

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

#include "WaveFile.h"

#define	INT8_UNSIGNED			unsigned char
#define	INT32_UNSIGNED			unsigned int
#define INT64_UNSIGNED			ULONGLONG
#define INT64_SIGNED			LONGLONG

#define STRINGOBJ               BSTR
#define STRINGPTR               TCHAR *
#define STRINGPREFIX(x)         _T(x)
#define STRINGLITERAL(x)		OLESTR(x)
#define STRINGCOPY(x)           SysAllocString(x)
#define STRINGFREE(x)           SysFreeString(x)

#define MUTEX					HANDLE //HANDLE

typedef void(*callback_onCapture)(void* handle, IDeckLinkVideoInputFrame* videoFrame);
typedef void(*callback_onAudioCapture)(void* handle, IDeckLinkAudioInputPacket* audioPacket);
typedef void(*callback_onChange)(void* handle, IDeckLinkDisplayMode *newDisplayMode, BMDPixelFormat pixelFormat);
typedef HRESULT(*callback_onSchedule)(void* handle, IDeckLinkVideoFrame* videoFrame);

HRESULT		Initialize();
HRESULT     GetDeckLinkIterator(IDeckLinkIterator **deckLinkIterator);
HRESULT		GetDeckLinkDiscoveryInstance(IDeckLinkDiscovery **deckLinkDiscovery);

void MutexInit(MUTEX* mutex);
void MutexLock(MUTEX* mutex);
void MutexUnlock(MUTEX* mutex);
void MutexDestroy(MUTEX* mutex);

// string helpers
void        StringFromCharArray(STRINGOBJ* newStr, const char* charPtr);
void        StringToCharArray(STRINGOBJ bmdStr, char* charArray, unsigned int arrayLength);
void        StringToStdString(STRINGOBJ bmdStr, std::string& stdStr);

// The input callback class
class NotificationCallback : public IDeckLinkInputCallback
{

public:
	IDeckLinkInput* m_deckLinkInput;
	callback_onCapture mpCaptureCallback;
	void* mpCaptureCallbackData;
	callback_onChange mpChangeCallback;
	void* mpChangeCallbackData;
	callback_onAudioCapture mpAudioCaptureCallback;
	void* mpAudioCaptureCallbackData;

	NotificationCallback(IDeckLinkInput *deckLinkInput, callback_onCapture cb1, void* data1, callback_onChange cb2, void* data2)
	{
		m_deckLinkInput = deckLinkInput;
		mpCaptureCallback = cb1;
		mpCaptureCallbackData = data1;
		mpChangeCallback = cb2;
		mpChangeCallbackData = data2;
		mpAudioCaptureCallback = NULL;
		mpAudioCaptureCallbackData = NULL;
	}

	~NotificationCallback(void)
	{

	}

	void setCallback_onAudioCapture(callback_onAudioCapture cb, void* data) {
		mpAudioCaptureCallback = cb;
		mpAudioCaptureCallbackData = data;
	}

	HRESULT		STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
	{
		return E_NOINTERFACE;
	}

	ULONG		STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}

	ULONG		STDMETHODCALLTYPE Release()
	{
		return 1;
	}

	// The callback that is called when a property of the video input stream has changed.
	HRESULT		STDMETHODCALLTYPE VideoInputFormatChanged(/* in */ BMDVideoInputFormatChangedEvents notificationEvents, /* in */ IDeckLinkDisplayMode *newDisplayMode, /* in */ BMDDetectedVideoInputFormatFlags detectedSignalFlags)
	{
		BMDPixelFormat pixelFormat = bmdFormat8BitYUV;
		STRINGOBJ			displayModeString = NULL;

		// Check for video field changes
		if (notificationEvents & bmdVideoInputFieldDominanceChanged)
		{
			BMDFieldDominance fieldDominance;

			fieldDominance = newDisplayMode->GetFieldDominance();
			printf("Input field dominance changed to ");
			switch (fieldDominance) {
			case bmdUnknownFieldDominance:
				printf("unknown\n");
				break;
			case bmdLowerFieldFirst:
				printf("lower field first\n");
				break;
			case bmdUpperFieldFirst:
				printf("upper field first\n");
				break;
			case bmdProgressiveFrame:
				printf("progressive\n");
				break;
			case bmdProgressiveSegmentedFrame:
				printf("progressive segmented frame\n");
				break;
			default:
				break;
			}
		}

		// Check if the pixel format has changed
		if (notificationEvents & bmdVideoInputColorspaceChanged)
		{
			printf("Input color space changed to ");
			if (detectedSignalFlags == bmdDetectedVideoInputYCbCr422)
			{
				printf("YCbCr422\n");
				//pixelFormat = bmdFormat10BitYUV;
				pixelFormat = bmdFormat8BitYUV;
			}
			if (detectedSignalFlags == bmdDetectedVideoInputRGB444)
			{
				printf("RGB444\n");
				//pixelFormat = bmdFormat10BitRGB;
				pixelFormat = bmdFormat8BitBGRA;
			}
		}

		// Notify pixel format
		mpChangeCallback(mpChangeCallbackData, newDisplayMode, pixelFormat);

		// Check if the video mode has changed
		if (notificationEvents & bmdVideoInputDisplayModeChanged)
		{
			std::string modeName;

			// Obtain the name of the video mode 
			newDisplayMode->GetName(&displayModeString);
			StringToStdString(displayModeString, modeName);

			printf("Input display mode changed to: %s\n", modeName.c_str());
			// Release the video mode name string
			STRINGFREE(displayModeString);
		}

		// Pause video capture
		m_deckLinkInput->PauseStreams();

		// Enable video input with the properties of the new video stream
		m_deckLinkInput->EnableVideoInput(newDisplayMode->GetDisplayMode(), pixelFormat, bmdVideoInputEnableFormatDetection);

		// Flush any queued video frames
		m_deckLinkInput->FlushStreams();

		// Start video capture
		m_deckLinkInput->StartStreams();

		return S_OK;
	}

	HRESULT		STDMETHODCALLTYPE VideoInputFrameArrived(/* in */ IDeckLinkVideoInputFrame* videoFrame, /* in */ IDeckLinkAudioInputPacket* audioPacket)
	{
		if (mpCaptureCallback && videoFrame)
			mpCaptureCallback(mpCaptureCallbackData, videoFrame);

		if (mpAudioCaptureCallback && audioPacket)
			mpAudioCaptureCallback(mpAudioCaptureCallbackData, audioPacket);

		return S_OK;
	}
};

class OutputCallback : public IDeckLinkVideoOutputCallback
{
public:
	IDeckLinkOutput* m_deckLinkOutput;
	callback_onSchedule mpScheduleCallback;
	void* mpScheduleCallbackData;

	OutputCallback(IDeckLinkOutput* deckLinkOutput, callback_onSchedule cb, void* data)
	{
		m_deckLinkOutput = deckLinkOutput;
		mpScheduleCallback = cb;
		mpScheduleCallbackData = data;
		m_deckLinkOutput->AddRef();
	}

	virtual ~OutputCallback(void)
	{
		m_deckLinkOutput->Release();
	}

	virtual HRESULT	STDMETHODCALLTYPE ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult completionResult)
	{
		//return scheduleNextFrame(completedFrame); // loop error...
		return S_OK;
	}

	virtual HRESULT	STDMETHODCALLTYPE ScheduledPlaybackHasStopped(void)
	{
		return S_OK;
	}

	// IUnknown needs only a dummy implementation
	virtual HRESULT	STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
	{
		return E_NOINTERFACE;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}

	virtual ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}

	virtual HRESULT scheduleNextFrame(IDeckLinkVideoFrame* videoFrame)
	{
		return mpScheduleCallback(mpScheduleCallbackData, videoFrame);
	}
};